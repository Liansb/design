# 工厂模式

## 定义

工厂顾名思义就是生产产品的意思，根据产品是具体产品还是具体工厂可分为简单工厂模式和工厂方法模式，根据工厂的抽象程度可分为工厂方法模式和抽象工厂模式。该模式用于封装和管理对象的创建，是一种创建型模式。

## 分类

### 简单工厂模式

一个具体工厂通过条件语句创建多个产品，产品的创建逻辑集中于一个工厂类。
客户端通过传不同的参数给工厂，实现创建不同产品的目的
增加新产品时，需要修改工厂类、增加产品类，不符合OCP原则(开闭原则)

> **简单工厂模式的优点：**
>
> - 工厂类是整个模式的关键。包含了必要的逻辑判断,根据外界给定的信息，决定究竟应该创建哪个具体类的对象。通过使用工厂类，外界可以从直接创建具体产品对象的尴尬局面摆脱出来，仅仅需要负责“消费”对象就可以了。而不必管这些对象究竟如何创建及如何组织的。明确了各自的职责和权利，有利于整个软件体系结构的优化。

> **简单工厂模式的缺点：**
>
> - 由于工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则，将全部创建逻辑集中到了一个工厂类中；它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。
> - 当系统中的具体产品类不断增多时候，可能会出现要求工厂类根据不同条件创建不同实例的需求。这种对条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系统的维护和扩展非常不利。
> - 这些缺点在工厂方法模式中得到了一定的克服。

> **可以考虑的应用场景：**
>
> - 工厂类负责创建的对象比较少；
> - 客户只知道传入工厂类的参数，对于如何创建对象（逻辑）不关心；
> - 由于简单工厂很容易违反高内聚责任分配原则，因此一般只在很简单的情况下应用。



### 工厂方法模式

一个工厂创建一个产品，所有的具体工厂继承自一个抽象工厂。
客户端先创建不同产品的工厂，再由工厂创建具体产品，产品的创建逻辑分散在每个具体工厂类中。
客户端只依赖于抽象工厂与抽象产品，不依赖任何具体的工厂与具体产品
增加新产品时，需要增加工厂类和产品类，符合OCP原则

> **工厂方法模式的优点：**
>
> - 用户只需要关心产品对应的工厂，甚至无需关心创建细节或具体产品类的类名。
> - 基于工厂角色和产品的多态性设计是工厂模式的关键。它能自主决定如何创建哪种产品对象，而创建细节都封装在具体工厂内部。
> - 在系统要添加新的产品时，无需修改抽象工厂和抽象产品提供的接口，无需修改客户端，也无需修改其他的具体工厂和具体产品，只要添加一个具体工厂和具体产品即可，从而提高系统的可扩展性（符合开闭原则）

> **工厂方法模式的缺点：**
>
> - 在添加新产品时，要编写新的具体产品类，并要提供与之对应的具体工厂类。系统软件个数也成对增加，从而增加了系统的复杂度，带来更多开销。
> - 由于系统的可扩展性，在客户端中要引入抽象层进行定义，从而增加了系统的抽象性和理解难度。



### 抽象工厂模式

一个具体工厂创建一个产品族，一个产品族是不同系列产品的组合，产品的创建的逻辑分在在每个具体工厂类中。所有的具体工厂继承自同一个抽象工厂。
客户端创建不同产品族的工厂，产品族的工厂创建具体的产品对客户端是不可见的。
增加新的产品族时，需要增加具体工厂类,符合OCP原则。
增加新产品时，需要修改具体工厂类和增加产品类，不符合OCP原则
如果没有应对“多系列对象创建”的需求变化，则没有必要使用抽象工厂模式，这时候使用简单的静态工厂完全可以。

> **抽象工厂模式的优点：**
>
> - 分离了具体的类。客户通过抽象接口操纵实例，产品的类名也在具体工厂的实现中被分离，它们不出现在客户代码中。
> - 易于交换产品系列。一个具体工厂类只在初始化时出现一次，这使得改变一个应用的具体工厂变得很容易，只需改变具体的工厂即可使用不同的产品配置。
> - 有利于产品的一致性。当一个系列的产品对象被设计成一起工作时，一个应用一次只能使用同一个系列中的对象，这一点很重要，而抽象工厂很容易实现这一点。

> **抽象工厂模式的缺点：**
>
> - 难以支持新种类的产品。因为抽象工厂接口确定了可以被创建的产品集合，所以难以扩展抽象工厂以生产新种类的产品。

> **可以考虑使用的场景：**
>
> - 一个系统要独立于它的产品的创建、组合和表示时。
> - 一个系统要由多个产品系列中的一个来配置时。
> - 需要强调一系列相关的产品对象的设计以便进行联合使用时。
> - 提供一个产品类库，而只想显示它们的接口而不是实现时。



## 参考博文

https://www.jianshu.com/p/1f758a91b3a4



